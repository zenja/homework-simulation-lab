external class demos="/home/wangxing/Software/cim-3.37/demos/demos.atr";

Demos
begin
    integer numSession;

    ref(rDist) sessionInterval_;    ! the interval between session arrives;
    ref(RDist) sessionTime_;        ! the life time of a session;
    ref(RDist) bitrateInterval_;    ! the interval between bitrate changes;
    ref(res) bandwidth_;            ! the bandwidth of the system;
    ref(bin) shutdown_;
    ref(bdist) drawSmartphone_;
    integer bMin_;
    integer bMax_;
    integer bStep_;

    ! statistical data;
    real dataAmount_;                ! all amount of transmitted data of all sessions;
    real timeAmount_;                ! all amount of  time of all sessions;
    ref(count) numBitrateChange_;    ! the number of bitrate changes;
    ref(count) numVeryGood_;         ! the number of very good quality of all sessions;
    ref(count) numAllSession_;       ! the number of all sessions, both effective ones and rejected ones;
    ref(count) numEffectiveSession_; ! the number of effective sessions;

    ! debug flag;
    boolean debugFlag_;

    procedure my_debug_r(msg, num); text msg; real num; begin
        if debugFlag_ then begin
            outtext(msg);
            outfix(num, 5, 0);
            outimage;
        end;
    end;

    procedure my_debug_i(msg, num); text msg; integer num; begin
        if debugFlag_ then begin
            outtext(msg);
            outfix(num, 0, 0);
            outimage;
        end;
    end;

    ! should be called after transmitting some amount of data with consistent bitrate;
    procedure updateTransmitCount(rate, time); integer rate; real time; begin
        dataAmount_ := dataAmount_ + rate*time;
        timeAmount_ := timeAmount_ + time;
    end;

    ! should be called when the bitrate is changed;
    procedure bitrateChanged; begin
        numBitrateChange_.update(1);
    end;

    entity class Generator;
    begin
        integer i;
        for i := 1 step 1 until numSession do
        begin
            integer sessionIntervalTime;
            sessionIntervalTime := sessionInterval_.sample;
            new Session(edit("Session", i)).schedule(0);
            hold(sessionIntervalTime);

            ! debug;
            my_debug_i("session interval: ", sessionIntervalTime);
        end;

    end;

    entity class Session;
    begin
        long real timestamp;
        long real endtime;
        integer acquiredBandwidth;
        boolean isSmartphone;

        ! acquire the bandwidth at the beginning of the session;
        ! and set the acquiredBandwidth;
        ! must make sure that there are at least bMax_ bandwidth;
        procedure acquire_first_bandwidth; begin
            integer num;

            !debug;
            my_debug_i("bandwidth available: ", bandwidth_.avail);

            ! try acquire max bandwidth or the remains;
            if bandwidth_.avail >= bMax_ then begin
                num := bMax_;
            end
            else begin
                num := bandwidth_.avail;
            end;
            bandwidth_.acquire(num);
            acquiredBandwidth := num;

            !debug;
            my_debug_i("first acquire: ", num);

            ! need this? I don't think so now..;
            !bitrate_changed;
        end;

        procedure change_bitrate; begin
            integer currentAvailBW;
            currentAvailBW := bandwidth_.avail;

            ! calculate the new bitrate;
            if currentAvailBW > bMin_ then
            begin
                ! increase bandwidth by bStep_ if not at max bitrate;
                if acquiredBandwidth < bMax_ then begin
                    bandwidth_.acquire(bStep_);
                    acquiredBandwidth := acquiredBandwidth + bStep_;
                end;
            end
            else
            begin
                ! decrease bandwidth by bStep_ if not at min bitrate;
                if acquiredBandwidth > bMin_ then begin
                    bandwidth_.release(bStep_);
                    acquiredBandwidth := acquiredBandwidth - bStep_;
                end;
            end;

            ! update statistical data;
            bitrate_changed;
        end;

        ! code to execute when the bitrate is changed;
        procedure bitrate_changed; begin
            numBitrateChange_.update(1);

            if ifVeryGood then begin
                numVeryGood_.update(1);
            end;
        end;

        ! judge if current bitrate is very good;
        boolean procedure ifVeryGood; begin
            if isSmartphone and acquiredBandwidth >= 4 then begin
                ifVeryGood := true;
            end
            else if not isSmartphone and acquiredBandwidth >= 6 then begin
                ifVeryGood := true;
            end
            else begin
                ifVeryGood := false;
            end;
        end;

        !--------------- statements ---------------;

        timestamp := time;
        endtime := timestamp + sessionTime_.sample;
        acquiredBandwidth := 0; ! init value;
        isSmartphone := drawSmartphone_.sample;

        ! debug;
        my_debug_r("session last time: ", endtime - timestamp);

        ! one new session;
        numAllSession_.update(1);

        ! if no enough resource left (bMin), reject the session;
        if bandwidth_.avail < bMin_ then begin
            goto kill_it;
        end;

        ! acquire bandwidth;
        acquire_first_bandwidth;

        ! one new effective session;
        numEffectiveSession_.update(1);

        ! keep changing bitrate until session's time up;
        while time < endtime do begin
            ! wait for next bitrate change...;
            ! -- hold: min(remaining time, sample time);
            real remainingTime, sampleTime, actualTime;
            sampleTime := bitrateInterval_.sample;
            remainingTime := endtime - time;
            if sampleTime > remainingTime then actualTime := remainingTime else actualTime := sampleTime;
            hold(actualTime);

            ! change bitrate;
            change_bitrate;

            ! updata statistical data;
            updateTransmitCount(acquiredBandwidth, actualTime);

            ! debug;
            my_debug_i("bitrate changed: ", acquiredBandwidth);
        end;

        ! IMPORTANT: release acquired bandwidth;
        bandwidth_.release(acquiredBandwidth);
        acquiredBandwidth := 0;

    kill_it:

        ! give a shutdown;
        shutdown_.give(1);

    end;

    numSession := 5000;  ! number of all sessions;

    sessionInterval_ :- new NegExp("session ITV", 1/4);
    sessionTime_ :- new NegExp("session T", 1/90);
    bitrateInterval_ :- new NegExp("bitrate ITV", 0.1);
    bandwidth_ :- new Res("bandwidth", 100);
    shutdown_ :- new Bin("shutdown", 0);
    drawSmartphone_ :- new Draw("is smartphone", 0.7);
    bMin_ := 2;
    bMax_ := 8;
    bStep_ := 2;

    ! init statistical data;
    dataAmount_ := 0.0;
    timeAmount_ := 0.0;
    numBitrateChange_ :- new count("BR Change");
    numVeryGood_ :- new count("Very Good");
    numAllSession_ :- new count("all_sessions");
    numEffectiveSession_ :- new count("effective_s");

    ! debug flag;
    debugFlag_ := false;

    ! ******************** Statements *********************;

    while REPLICATION <= 10 do begin
        ! generate sessions;
        new Generator("Generator").schedule(0);

        ! wait for all sessions are finished;
        shutdown_.take(numSession);

        ! print statistical data which cannot be printed automatically;
        outtext("***Average bitrate:***");
        outfix(dataAmount_/timeAmount_, 2, 0);
        outimage;

        REPLICATE;
    end;

end;
